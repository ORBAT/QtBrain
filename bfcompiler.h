/*
Copyright 2010 Tom Eklof. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, this list of
      conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright notice, this list
      of conditions and the following disclaimer in the documentation and/or other materials
      provided with the distribution.

THIS SOFTWARE IS PROVIDED BY TOM EKLOF ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL TOM EKLOF OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef BFCOMPILER_H
#define BFCOMPILER_H

#include "bfvm.h"
#include <QObject>
#include <QList>


namespace QtBrain {

    /**
      This class is used to compile "normal" Brainfuck into the VM's internal binary
      representation

      This is done by first cleaning the input source file so that the only characters left
      are the 8 legal Brainfuck commands +-<>[],.
      Then the string is read a character at a time and "compiled" into BfVM bytecode (which
      can be found in the BfVM header). If the source can't be compiled for whatever reason,
      a signal is emitted with a message and a guess of where the error might be.

      When compilaton finishes, the compiler emits the following:
      - bytecode of the compiled program
      - a BiHash of the JZ/JNZ instruction positions
      - a BiHash of how the generated bytecode "maps" into the original source code:

          For example, if the source was this:
          [ < + >]
          01234567  Position in string

          It would get cleaned to:
          [<+>]
          01234    Position in cleaned source

          Position 4 in the cleaned source would then _map_ to position 7 in the original,
          position 2 of the cleaned would map to position 4 of the original and so on.

          the "left" side of the BiHash is the position in the cleaned source, and the
          "right" side is the original.


      What the compiler checks for:
      - Is the program smaller than the maximum size allowed by the VM?
      - Are all braces matched?

      */


    class BfCompiler : public QThread
    {
        Q_OBJECT
    public:
        /////////////////////////////////////////////////////////////////////////////////////
        //// PUBLIC METHODS
        ///////////////////
        BfCompiler(QObject *parent = 0);
        ~BfCompiler();

    signals:
        /////////////////////////////////////////////////////////////////////////////////////
        //// SIGNALS
        ////////////


        void error(const QString& message, quint32 position=0);
                                                    /* emitted whenever the compiler finds
                                                       an error in the source code and can't
                                                       finish compilation. The compiler's
                                                       best _guess_ for the error's location
                                                       is also sent */



        void compiled(const QList<BfOpcode>&, BiHash<IPType,IPType> &jmps,
                      BiHash<IPType,quint32> &mappings);
                                                    /* emitted when compilation succeeds.
                                                       Contains the compiled program, a
                                                       BiHash of JZ and JNZ locations and
                                                       a BiHash of the mappings between
                                                       the original source and the cleaned
                                                       source (see comments for explanation)
                                                       */

    protected:
        /////////////////////////////////////////////////////////////////////////////////////
        //// PROTECTED MEMBER VARIABLES
        ///////////////////////////////

        bool m_error; // set when an error is found

        /////////////////////////////////////////////////////////////////////////////////////
        //// PROTECTED METHODS
        //////////////////////
        void run();                                 // QThread

        /**
          compiles a string into BfVM bytecode, returns the bytecodes and a mapping from
          the original source into the "cleaned" source in the reference &mappings.

          &mappings needs to be initialized by the calling function!

          */
        QList<BfOpcode> compileSource(const QString& src, BiHash<IPType,quint32> &mappings);

        /**
          Returns the opcode that corresponds to the given character, or INVALID if
          it's not a valid Bf command
          */
        BfOpcode charToOpcode(const QChar&);


        /**
          Memoizes destinations for the JZ and JNZ operators. Will emit an error if it
          finds unbalanced jumps.

          The mapping data is passed in so that a proper error message can be sent.

          Returns an empty BiHash if it finds an error.
          */
        //      JZ     JNZ
        BiHash<IPType,IPType> memoizeJumps(const QList<BfOpcode>&, BiHash<IPType, quint32>
                                           &mappings);



    public slots:
        /////////////////////////////////////////////////////////////////////////////////////
        //// SLOTS FOR EXTERNAL USE
        ///////////////////////////
        void compile(const QString&);               /* compiles the given string into the
                                                       VM's internal representation. Emits a
                                                       signal on either success or error.
                                                       If an error is encountered,
                                                       compilation is stopped and no
                                                       further errors are reported. */





    };
}
#endif // BFCOMPILER_H
